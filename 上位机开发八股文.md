# 一、线程和进程
## 1.异步IO和同步IO区别？
- IO是input output
如果是同步IO，当一个IO操作执行时，应用程序必须等待，直到此IO执行完。相反，异步IO操作在后台运行，IO操作和应用程序可以同时运行，提高系统性能，提高IO流量。
## 2.进程间通信方式？

| 管道(pipe)            | 是一种**半双工**的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程之间使用，通常是**父子进程**。                                             |
| ------------------- | -------------------------------------------------------------------------------------------------------- |
| 有名管道(named pipe)    | 也是**半双工**的通信方式，但是它**允许用于无亲缘关系的进程**之间的通信。                                                                 |
| 信号量(semophore)      | 是一个**计数器**，通常作为一种同步机制，**用于进程和线程间的同步**。                                                                   |
| 消息队列(message queue) | 是**进程间通信（IPC）机制**，消息队列是一个存储消息的**先进先出（FIFO）队列**，存放在内核中。每个消息队列都有一个唯一的标识符，用于区分不同的队列。                        |
| 共享内存(shared memory) | 一段**能够被多个进程共同访问的内存**，**由一个进程创建**。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而设计的，往往与其他通信方式如信号量配合使用，来实现**进程间同步与通信**。 |
| 套接字(socket)         | 可用于**不同主机间**的进程通信。                                                                                       |
| 信号(signal)          | 用于通知接收进程某个事件已经发生，是一种比较复杂的通信方式。                                                                           |

## 3.进程的地址空间模型？
![[Snipaste_2025-02-15_06-10-25.png]]

| text segment                | 存储代码的区域                                                                                                   |
| --------------------------- | --------------------------------------------------------------------------------------------------------- |
| data segment                | 存储初始化不为0的全局变量和静态变量、const型常量                                                                               |
| bss segment                 | 存储未初始化的、初始化为0的全局变量和静态变量                                                                                   |
| heap（堆）                     | 用于动态开辟内存空间                                                                                                |
| memory mapping space（内存映射区） | mmap系统调用使用的空间，通常用于文件映射到内存或匿名映射（开辟大块空间），当malloc大于128k时（此处依赖于glibc的配置），也使用该区域。在进程创建时，会将程序用到的平台、动态链接库加载到该区域。 |
| stack（栈）                    | 存储函数参数、局部变量                                                                                               |
| kernel space                | 存储内核代码                                                                                                    |
- `mmap`是一个系统调用（System Call），用于将文件或设备映射到进程的地址空间。简单来说，它可以让文件的内容直接在内存中被访问，就像访问普通内存一样。
- `malloc`是C标准库中用于动态分配内存的函数，当`malloc`请求的内存大小较大时，底层会使用`mmap`来分配内存
## 4.进程的五种状态分别是?
![[Snipaste_2025-02-15_06-19-15.png]]
1. **就绪态**：所有运行条件已就绪，只要得到了CPU时间就可运行
2. **运行态**：得到CPU时间正在运行
3. **僵尸态**：进程已经结束了但父进程还没来得及回收
4. **等待态**：包括浅度睡眠跟深度睡眠。进程在等待某种条件，条件成熟后即进入就绪态。浅度睡眠时进程可以被信号唤醒，但深度睡眠时必须等到条件成熟后才能结束睡眠状态
5. **暂停态**：暂时停止参与CPU调度（即使条件成熟），可以恢复
## 5.子进程从父进程继承的资源有哪些？
用户号和用户组号、目录（当前目录、根目录）、打开的文件描述符、堆栈、共享内存
- 父进程和子进程拥有独立的地址空间和PID参数、自己的文件描述符、不同的父进程号
- **PID（Process ID）** 是 **进程标识符（Process Identifier）**
## 6.什么是进程上下文、中断上下文？
1. **进程上文**：是指进程由用户态切换到内核态时需要保存用户态时CPU寄存器中的值，进程状态以及堆栈上的内容。即**保存当前进程的状态，以便再次执行该进程时，能够恢复切换时的状态，继续执行**。
2. **进程下文**：是**指切换到内核态后执行的程序**，即进程运行在内核空间的部分。
3. **中断上文**：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。中断上文可以看作**硬件传递过来的这些参数**和内核需要保存的一些其他环境（**主要是当前被中断的进程环境**）。
4. **中断下文**：执行在内核空间的中断服务程序
## 7.如何防止僵尸进程过多导致系统空间爆满？
每当子进程退出，父进程都会收到SIGCHLD信号，故可在父进程中**设置SIGCHLD信号的捕获函数**，**在捕获函数中回收子进程**。
```c
void* handler(int sig) {
	int status;
	if(waitpid(-1, &status, WNOHANG) >= 0) {
		printf("child is die\n");
	}
}

int main() {
	signal(SIGCHLD, handler);
	
	int pid = fork();
	if(pid > 0) { //父进程循环等待
		while(1) {
			sleep(2);
		}
	} else if(0 == pid) { //子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD
						  //信号调用handler函数接收结束子进程，打印child is die。
		printf("i am child, i die\n");
		exit(0);
	}
}
```
- 命令查看僵尸进程的数量（zombie），可用`ps -aux | grep Z`
## 8./proc目录下，以数字命名的目录表示什么？
以数字命名的目录表示当前一个运行的进程，目录名即为进程PID，其内的目录和文件给出了一些关于该进程的信息
## 9.进程和线程有什么区别？
- **进程**是程序在执行期间的一个实例，是操作系统进行资源分配和调度的基本单位。它包含了程序运行所需的所有资源，如内存空间、文件句柄、环境变量等。
- **线程**是进程中的一个执行单元，是操作系统能够进行调度的最小单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存空间、文件描述符等），但每个线程有自己的执行栈和程序计数器。
## 10.什么时候用多进程？什么时候用多线程？
- 当程序的安全性、稳定性要求较高时用多进程。
- 需要频繁通信/切换程序/创建跟销毁程序时用多线程。
## 11.线程可以独立运行吗？一个线程崩溃会导致整个进程崩溃吗？
**线程不能独立运行**，但**一个线程崩溃不一定导致整个进程崩溃**。
## 12.写出下列线程、互斥锁、信号量相关代码(这个有点鸡肋)
这一系列操作来自于 **POSIX线程库（pthread）** 和 **POSIX信号量库**，它们是用于多线程编程和同步机制的标准库，定义在 `<pthread.h>` 和 `<semaphore.h>` 中。
```c
//定义一个线程ID变量
pthread_t tid;
//创建线程
pthread_create(&tid, NULL, pthread_func, NULL);
//等待子线程结束，并回收资源
pthread_join(tid, NULL);
//与当前进程分离
pthread_detach(tid);
//退出调用线程
pthread_exit(NULL);
//取消线程
pthread_cancel(tid);
//创建互斥锁
pthread_mutex mutex = PTHREAD_MUTEX_INITIALIZER;
//初始化一个互斥锁
pthread_mutex_init(&mutex, NULL);
//对互斥锁上锁
pthread_mutex_lock(&mutex);
//对互斥锁解锁
pthread_mutex_unlock(&mutex);
//定义一个信号量
sem_t sem;
//创建信号量并初始化它的值
sem_init(&sem, 0, 1);
//信号量的值减1
sem_wait(&sem);
//信号量的值加1
sem_post(&sem);
```
## 13.线程间通信和同步方式有哪些？
信号、信号量、互斥锁、条件变量、自旋锁、读写锁
## 14.如何防止同时产生大量的线程？
1. 方法是使用线程池
2. 线程池可以提高调度效率和限制资源使用，线程池中的线程达到最大数时，其他线程就会排队等候
## 15.互斥锁与信号量的区别？
- 信号量用于线程同步，互斥锁用于线程互斥
- 信号量可以为非负整数，可以实现多个同类资源的多线程同步；互斥锁只能为0/1，只能用于一个资源的互斥访问
- 信号量可以由一个线程释放，另一个线程得到；互斥锁的加锁和解锁必须由同一线程分别对应使用，且多个线程使用多个互斥锁必须注意统一顺序，否则可能造成死锁
## 16.一个进程可以创建多少个线程？和什么有关？
- 一个进程创建线程的个数由虚拟内存的大小和分配给线程的调用栈大小决定。一个线程的栈大小可通过`ulimit -s`查看，一般是8~10M
# 二、网络编程
## 1.列举一下OSI协议的各种分层。说说你最熟悉的一层协议的功能
![[Snipaste_2025-02-16_10-36-33.png]]
- 四层划分为：应用层、传输层、网络层、网络接口层。（TCP/IP协议对应模型）
- 五层划分为：应用层、传输层、网络层、数据链路层、物理层。
- 七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

| 应用层   | 在实现多个应用进程相互通信的同时，完成一系列业务处理所需的服务，比如电子邮件、文件传输、远程登录等。          |
| ----- | ----------------------------------------------------------- |
| 传输层   | 为通信双方的主机提供端到端的服务，有两个不同的传输协议TCP和UDP，TCP提供可靠交付，而UDP并不能保证可靠交付。 |
| 网络层   | 处理分组在网络中的活动，例如分组的选路。                                        |
| 网络接口层 | 处理与电缆（或其他任何传输媒介）的物理接口细节。                                    |
## 2.TCP/IP协议包括？

| 应用层   | Telnet（远程登录服务）、FTP（文件传输，使用TCP）、SMTP（建立于FTP上的邮件服务）、DNS（域名与IP地址相互转换）等        |
| ----- | -------------------------------------------------------------------------- |
| 传输层   | UDP（无连接、不可靠）、TCP（面向连接、可靠传输）                                                |
| 网络层   | IP（为主机提供一种无连接、不可靠、尽力而为的数据服务）、ICMP（主机与路由器之间传递控制信息）、IGMP（主机与路由器之间进行组播成员信息交互） |
| 网络接口层 | ARP（IP 地址-> MAC地址）、RARP（MAC地址 -> IP地址）等                                    |
## 3.TCP通信建立和释放的过程？端口的作用？
- 连接是三次握手，释放是四次挥手。
- 端口是一个软件结构，被客户进程或服务进程用来发送和接收信息。一个端口对应一个16比特的数。服务进程通常使用一个固定的端口。
## 4.IP地址转换成物理地址的协议？反之？
- 将IP地址转换成物理地址的协议是ARP（地址解析协议）。
- 反之则是RARP（反地址解析协议）。
## 5.IP地址的编码分为哪两部分？
IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。
## 6.应用程序ping发出的是什么报文？
应用程序ping发出的是ICMP请求报文。
## 7.socket编程的流程？
### 7.1服务器端流程：

| 函数       | 作用           |
| -------- | ------------ |
| socket() | 创建套接字        |
| bind()   | 绑定本地IP地址和端口号 |
| listen() | 设置监听队列长度     |
| accept() | 等待连接         |
| read()   | 接收信息         |
| close()  | 关闭套接字        |
### 7.2客户端流程：

| 函数        | 作用     |
| --------- | ------ |
| socket()  | 创建套接字  |
| connect() | 发送连接请求 |
| write()   | 发送信息   |
| close()   | 关闭套接字  |
## 8.epoll是什么？
- epoll是Linux网络编程中用于处理大批量文件描述符的机制，是对select/poll的改进。
- select监听的fd是有上限的，32位处理器一般为1024；且select/poll每次调用会遍历所有fd，时间复杂度为O(n)，效率太低。而epoll监听的fd数量没有限制，且能在O(1)的时间复杂度内完成操作。
- epoll相关的系统调用有：epoll_creat、epoll_ctl、epoll_wait/epoll_pwait（可屏蔽特定信号），分别用来创建一个epoll文件描述符、添加/删除/修改需要侦听的文件描述符及事件、接收被侦听描述符的IO事件。epoll文件描述符用完之后直接close关闭即可。
## 9.TCP、UDP的区别？
1. TCP是面向连接的，UDP是面向无连接的。
2. TCP是面向字节流的，UDP是基于数据报的。
3. TCP提供可靠服务（正确性、顺序性），UDP提供不可靠服务。
4. TCP程序结构复杂，占用资源多；UDP程序结构简单，占用资源少。
5. TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，适合于实时应用，如IP电话、实时视频会议。
6. TCP只支持一对一；UDP支持一对一、一对多、多对一、多对多。
## 10.TCP、UDP的优缺点？
1. TCP
- 优点：稳定可靠。在传输数据之前，会有三次握手来建立连接；在数据传输时，有校验和、确认、重传、序列号、窗口、拥塞控制机制；在数据传输结束后，还会有四次挥手来断开连接，节约系统资源。
- 缺点：效率低、占用系统资源多、易受攻击。建立连接和确认、重传、窗口、拥塞控制机制都会消耗大量时间；每台设备维护连接都会占用CPU、内存等资源；三次握手机制、确认机制导致TCP易受利用和攻击。
2. UDP
- 优点：效率高、占用系统资源较少、比TCP稍安全。没有各种复杂机制，传输速度快，占用系统资源较少，被利用的漏洞也少一些。
- 缺点：不稳定、不可靠。没有各种复杂机制，网络质量不好时很容易丢包。
## 11.TCP、UDP使用场景？
- TCP：对网络质量有要求时，比如HTTPS、HTTP、FTP等文件传输协议，POP、SMTP等邮件传输协议。
- UDP：对网络质量要求不高时，要求网络通讯速度要快的场景，比如在线视频、网络语音电话、广播通信。
## 12.TCP为什么是可靠连接？
因为TCP传输的数据满足四大条件：不出错、不丢失、不重复、不乱序，而且拥有窗口机制、拥塞控制机制来提高传输效率。
## 13.TCP如何保证可靠传输？
- 校验和：发送数据报的二进制相加然后取反，检测数据在传输过程中的变化，有差错则丢弃。
- 确认应答：接收方收到正确的报文就会确认。
- 超时重传：发送方等待一定时间后没有收到确认报文则重传。
- 序列号：发送方对每一个数据包编号，接收方对数据包排序，保证不乱序、不重复。
- 窗口机制（流量控制）：双方会协调发送的数据包大小，保证接收方能及时接收。
- 拥塞控制机制：如果网络拥塞，发送方会降低发送速率，降低整个网络的拥塞程度。
## 14.简述三次握手的过程。
![[Snipaste_2025-02-16_10-54-37.png]]
1. 最初两端的TCP进程都处于CLOSED状态，A主动打开链接而B被动打开链接。B的TCP服务器先创建传输控制块TCB，然后服务器进程就处于LISTEN状态，等待客户端的连接请求。若有则作出响应。
2. 第一次握手：客户端创建传输控制块，然后向服务器发出连接请求报文（将标志位SYN置1，随机产生一个序列号seq=x），接着进入SYN-SENT状态。
3. 第二次握手：服务器收到请求报文后由SYN=1得到客户端请求建立连接，回复一个确认报文（将标志位SYN和ACK都置1，ack=x+1，随机产生一个序列号seq=y），接着进入SYN-RCVD状态。此时操作系统为该TCP连接分配TCP缓存和变量。
4. 第三次握手：客户端收到确认报文后，检查ack是否为x+1，ACK是否为1，是则发送确认报文（将标志位ACK置1，ack=y+1，序列号seq=x+1），此时操作系统为该TCP连接分配TCP缓存和变量。服务器收到确认报文并检查无误后则连接建立成功，两者都进入ESTABLISHED状态，完成三次握手。
## 15.为什么需要三次握手，第三次握手去掉行不行？
NO
- 首先，第三次握手是为了防止已经失效的连接请求报文突然传输到了服务器，从而建立错误的连接，浪费资源。
- 其次，第三次握手还能防止发生死锁，因为若为两次握手且服务器发出第二次握手而客户端没有收到，服务器开始传输数据报后客户端便不会理会，导致服务器以为丢包而源源不断地发送数据报，造成死锁。
